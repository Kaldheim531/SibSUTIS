#include <stdio.h>
#include <math.h>

// Константы модели
#define DAYS 91          // Количество дней для моделирования
#define N 2798170.0      // Общая численность населения
#define dt 1.0           // Шаг по времени (1 день)
#define tau 2.0          // Задержка в днях для функции ct_tau
// Функция изоляции - возвращает коэффициент изоляции (в данном случае константа 1.0)
double c_isol(double t) {
    return 1.0;          // В текущей модели изоляция не учитывается (всегда 1.0)
}
// Функция задержки изоляции - учитывает временную задержку tau
double ct_tau(double t) {
    if (t - tau < 0)     // Если время меньше задержки, используем начальное значение
        return c_isol(0.0);
    else                 // Иначе используем значение с задержкой tau
        return c_isol(t - tau);
}
int main() {
    // Параметры модели SEIRD
    double alf_E = 0.999;  // Коэффициент передачи от Exposed (подвергшихся)
    double alf_I = 0.999;  // Коэффициент передачи от Infected (инфицированных)
    double k = 0.042;      // Скорость перехода из E в I
    double ro = 0.952;     // Скорость выздоровления из E
    double beta = 0.999;   // Скорость выздоровления из I
    double u = 0.0188;     // Смертность
    double gamma = 0.001;  // Скорость потери иммунитета
    // Массивы для хранения состояний модели по дням
    double S[DAYS];  // Susceptible (восприимчивые)
    double E[DAYS];  // Exposed (подвергшиеся)
    double I[DAYS];  // Infected (инфицированные)
    double R[DAYS];  // Recovered (выздоровевшие)
    double D[DAYS];  // Dead (умершие)
    // Начальные условия (день 0)
    S[0] = 2798047;  // Начальное число восприимчивых
    E[0] = 99;       // Начальное число подвергшихся
    I[0] = 0;        // Начальное число инфицированных
    R[0] = 24;       // Начальное число выздоровевших
    D[0] = 0;        // Начальное число умерших
    // Численное решение системы дифференциальных уравнений (метод Эйлера)
    for (int i = 0; i < DAYS - 1; i++) {
        double t = i;  // Текущее время (день)
        // Вычисление текущего коэффициента изоляции с учетом задержки
        double ctau = ct_tau(t);
        // Вычисление производных для каждого состояния
        double dS = -ctau * ((alf_I * S[i] * I[i]) / N + (alf_E * S[i] * E[i]) / N) + gamma * R[i];
        double dE = ctau * ((alf_I * S[i] * I[i]) / N + (alf_E * S[i] * E[i]) / N) - (k + ro) * E[i];
        double dI = k * E[i] - beta * I[i] - u * I[i];
        double dR = beta * I[i] + ro * E[i] - gamma * R[i];
        double dD = u * I[i];
        // Обновление состояний на следующий день
        S[i+1] = S[i] + dt * dS;
        E[i+1] = E[i] + dt * dE;
        I[i+1] = I[i] + dt * dI;
        R[i+1] = R[i] + dt * dR;
        D[i+1] = D[i] + dt * dD;
    }
    // Вывод результатов
    printf("День    S               E       I       R       D\n");
    for (int i = 0; i < DAYS; i++) {
        printf("%d\t%.2f\t%.2f\t%.2f\t%.2f\t%.2f\n", i, S[i], E[i], I[i], R[i], D[i]);
    }
    return 0;
}
